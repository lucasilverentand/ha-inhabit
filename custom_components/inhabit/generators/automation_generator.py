"""Generate Home Assistant automations from visual rules."""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

import yaml
from homeassistant.core import HomeAssistant

if TYPE_CHECKING:
    from ..models.automation_rule import VisualRule
    from ..store.floor_plan_store import FloorPlanStore

_LOGGER = logging.getLogger(__name__)


class AutomationGenerator:
    """Generates Home Assistant automation YAML from visual rules."""

    def __init__(self, hass: HomeAssistant, store: FloorPlanStore) -> None:
        """Initialize the generator."""
        self.hass = hass
        self._store = store

    def generate_automation(self, rule: VisualRule) -> dict[str, Any]:
        """Generate a single automation from a visual rule."""
        return rule.to_ha_automation()

    def generate_all_automations(self, floor_plan_id: str) -> list[dict[str, Any]]:
        """Generate automations for all rules in a floor plan."""
        rules = self._store.get_visual_rules(floor_plan_id)
        return [rule.to_ha_automation() for rule in rules if rule.enabled]

    def export_yaml(self, floor_plan_id: str) -> str:
        """Export all automations as YAML string."""
        automations = self.generate_all_automations(floor_plan_id)

        # Add header comment
        yaml_str = "# Generated by Inhabit Floor Plan Builder\n"
        yaml_str += "# Do not edit manually - changes may be overwritten\n\n"
        yaml_str += yaml.dump(
            automations,
            default_flow_style=False,
            allow_unicode=True,
            sort_keys=False,
        )

        return yaml_str

    def generate_occupancy_automation(
        self,
        room_id: str,
        room_name: str,
        target_entity_ids: list[str],
        turn_on: bool = True,
        timeout_seconds: int | None = None,
    ) -> dict[str, Any]:
        """
        Generate a standard occupancy-based automation.

        Args:
            room_id: Room identifier
            room_name: Human-readable room name
            target_entity_ids: List of entity IDs to control
            turn_on: True to turn on when occupied, False for when vacant
            timeout_seconds: Optional delay before action (for turn_off)
        """
        trigger_state = "on" if turn_on else "off"
        action = "turn_on" if turn_on else "turn_off"

        automation: dict[str, Any] = {
            "alias": f"{room_name} {'Lights On' if turn_on else 'Lights Off'} on {'Occupancy' if turn_on else 'Vacancy'}",
            "description": f"Auto-generated by Inhabit for {room_name}",
            "mode": "single",
            "trigger": [
                {
                    "platform": "state",
                    "entity_id": f"binary_sensor.fp_{room_id}_occupancy",
                    "to": trigger_state,
                }
            ],
            "action": [],
        }

        # Add timeout if specified
        if timeout_seconds and not turn_on:
            automation["trigger"][0]["for"] = {"seconds": timeout_seconds}

        # Add actions for each target entity
        for entity_id in target_entity_ids:
            domain = entity_id.split(".")[0]
            automation["action"].append(
                {
                    "service": f"{domain}.{action}",
                    "target": {"entity_id": entity_id},
                }
            )

        return automation

    def generate_presence_lighting_pair(
        self,
        room_id: str,
        room_name: str,
        light_entity_ids: list[str],
        off_delay_seconds: int = 300,
    ) -> list[dict[str, Any]]:
        """
        Generate a pair of automations for presence-based lighting.

        Creates:
        1. Lights on when occupied
        2. Lights off when vacant (with delay)
        """
        return [
            self.generate_occupancy_automation(
                room_id, room_name, light_entity_ids, turn_on=True
            ),
            self.generate_occupancy_automation(
                room_id,
                room_name,
                light_entity_ids,
                turn_on=False,
                timeout_seconds=off_delay_seconds,
            ),
        ]
